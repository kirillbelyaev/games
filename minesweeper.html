<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Minesweeper 2026</title>
    <style>
        :root {
            --bg: #0f172a;
            --glass: rgba(255, 255, 255, 0.05);
            --border: rgba(255, 255, 255, 0.1);
            --accent: #38bdf8;
            --mine: #f43f5e;
            --font-main: 'Inter', system-ui, -apple-system, sans-serif;
        }

        body {
            background-color: var(--bg);
            background-image: 
                radial-gradient(at 0% 0%, rgba(56, 189, 248, 0.15) 0px, transparent 50%),
                radial-gradient(at 100% 100%, rgba(244, 63, 94, 0.1) 0px, transparent 50%);
            color: white;
            font-family: var(--font-main);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .game-container {
            background: var(--glass);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 2rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .stats-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            background: rgba(0,0,0,0.2);
            padding: 10px 20px;
            border-radius: 12px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }

        #reset-btn {
            font-size: 2rem;
            cursor: pointer;
            background: none;
            border: none;
            transition: transform 0.2s;
        }

        #reset-btn:hover { transform: scale(1.2); }

        #grid {
            display: grid;
            gap: 4px;
            background: rgba(255, 255, 255, 0.03);
            padding: 8px;
            border-radius: 12px;
            user-select: none;
        }

        .cell {
            width: 35px;
            height: 35px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: 900;
            font-size: 1.1rem;
            transition: all 0.15s ease;
        }

        .cell:hover:not(.revealed) {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px var(--accent);
        }

        .cell.revealed {
            background: rgba(0, 0, 0, 0.3);
            cursor: default;
        }

        .cell.mine { background-color: var(--mine); }
        .cell.flagged { color: #fbbf24; }

        /* Digit Colors */
        .n1 { color: #38bdf8; } .n2 { color: #4ade80; }
        .n3 { color: #fb7185; } .n4 { color: #818cf8; }
        .n5 { color: #fbbf24; } .n6 { color: #2dd4bf; }
        .n7 { color: #e879f9; } .n8 { color: #94a3b8; }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="stats-bar">
            <div id="mine-count">010</div>
            <button id="reset-btn">ðŸ˜Š</button>
            <div id="timer">000</div>
        </div>
        <div id="grid"></div>
    </div>

    <script>
        const CONFIG = { rows: 10, cols: 10, mines: 12 };
        let board = [];
        let revealedCount = 0;
        let gameOver = false;
        let timer = 0;
        let timerInterval;

        const gridElement = document.getElementById('grid');
        const resetBtn = document.getElementById('reset-btn');
        const mineDisplay = document.getElementById('mine-count');
        const timerDisplay = document.getElementById('timer');

        function init() {
            gameOver = false;
            revealedCount = 0;
            timer = 0;
            clearInterval(timerInterval);
            timerDisplay.innerText = "000";
            mineDisplay.innerText = CONFIG.mines.toString().padStart(3, '0');
            resetBtn.innerText = "ðŸ˜Š";
            
            gridElement.style.gridTemplateColumns = `repeat(${CONFIG.cols}, 1fr)`;
            createBoard();
        }

        function createBoard() {
            gridElement.innerHTML = '';
            board = [];
            
            for (let r = 0; r < CONFIG.rows; r++) {
                board[r] = [];
                for (let c = 0; c < CONFIG.cols; c++) {
                    const cellEl = document.createElement('div');
                    cellEl.classList.add('cell');
                    cellEl.addEventListener('click', () => handleLeftClick(r, c));
                    cellEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleRightClick(r, c);
                    });
                    
                    gridElement.appendChild(cellEl);
                    board[r][c] = {
                        mine: false,
                        revealed: false,
                        flagged: false,
                        count: 0,
                        element: cellEl
                    };
                }
            }
            placeMines();
            calculateNumbers();
        }

        function placeMines() {
            let placed = 0;
            while (placed < CONFIG.mines) {
                let r = Math.floor(Math.random() * CONFIG.rows);
                let c = Math.floor(Math.random() * CONFIG.cols);
                if (!board[r][c].mine) {
                    board[r][c].mine = true;
                    placed++;
                }
            }
        }

        function calculateNumbers() {
            for (let r = 0; r < CONFIG.rows; r++) {
                for (let c = 0; c < CONFIG.cols; c++) {
                    if (board[r][c].mine) continue;
                    let count = 0;
                    traverseNeighbors(r, c, (nr, nc) => {
                        if (board[nr][nc].mine) count++;
                    });
                    board[r][c].count = count;
                }
            }
        }

        function traverseNeighbors(r, c, callback) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    let nr = r + dr, nc = c + dc;
                    if (nr >= 0 && nr < CONFIG.rows && nc >= 0 && nc < CONFIG.cols) {
                        callback(nr, nc);
                    }
                }
            }
        }

        function handleLeftClick(r, c) {
            if (gameOver || board[r][c].revealed || board[r][c].flagged) return;
            
            if (timer === 0) startTimer();

            if (board[r][c].mine) {
                endGame(false);
                return;
            }

            revealCell(r, c);
            if (revealedCount === (CONFIG.rows * CONFIG.cols) - CONFIG.mines) {
                endGame(true);
            }
        }

        function revealCell(r, c) {
            const cell = board[r][c];
            if (cell.revealed) return;

            cell.revealed = true;
            revealedCount++;
            cell.element.classList.add('revealed');
            
            if (cell.count > 0) {
                cell.element.innerText = cell.count;
                cell.element.classList.add(`n${cell.count}`);
            } else {
                traverseNeighbors(r, c, (nr, nc) => revealCell(nr, nc));
            }
        }

        function handleRightClick(r, c) {
            if (gameOver || board[r][c].revealed) return;
            const cell = board[r][c];
            cell.flagged = !cell.flagged;
            cell.element.innerText = cell.flagged ? "ðŸš©" : "";
            cell.element.classList.toggle('flagged');
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                timer++;
                timerDisplay.innerText = timer.toString().padStart(3, '0');
            }, 1000);
        }

        function endGame(won) {
            gameOver = true;
            clearInterval(timerInterval);
            resetBtn.innerText = won ? "ðŸ˜Ž" : "ðŸ˜µ";
            
            board.flat().forEach(cell => {
                if (cell.mine) {
                    cell.element.innerText = "ðŸ’£";
                    cell.element.classList.add('revealed', 'mine');
                }
            });
            if (won) alert("2026 Victory! System Secured.");
        }

        resetBtn.addEventListener('click', init);
        init();
    </script>
</body>
</html>
